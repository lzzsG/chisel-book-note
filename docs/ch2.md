# 第2章：基础组件

数字设计的核心在于组合逻辑电路和触发器，这些基本组件是构建更大、更复杂电路的基础。数字系统通常使用二进制信号，即单个位或信号只能表示两个可能值：0 和 1。这些值也常用以下术语描述：低/高（low/high）、假/真（false/true）、未断言/断言（deasserted/asserted）。无论采用哪种术语，均表示二进制信号的两个可能状态。

## 2.1 Chisel 类型与常量

Chisel 提供了三种基本数据类型，用于描述硬件连接、组合逻辑和寄存器：

1. **Bits**：表示位向量。
2. **UInt**：无符号整数，扩展自 Bits。
3. **SInt**：有符号整数，扩展自 Bits，使用二进制补码表示。

以下是这些类型的定义示例：

```scala
Bits(8.W)   // 8 位的 Bits 类型
UInt(8.W)   // 8 位无符号整数
SInt(10.W)  // 10 位有符号整数
```

### 宽度定义

位向量的宽度通过 Chisel 的宽度类型（`Width`）定义。可以使用 `n.W` 将整数 `n` 转换为 Chisel 宽度类型。例如：

```scala
Bits(8.W)   // 定义一个宽度为 8 的 Bits 向量
```

### 常量定义

Chisel 提供了简洁的语法定义常量，可以通过将 Scala 整数转换为 Chisel 类型：

```scala
0.U        // 定义一个值为 0 的 UInt 常量
-3.S       // 定义一个值为 -3 的 SInt 常量
3.U(4.W)   // 定义一个宽度为 4 的 UInt 常量，值为 3
```

这些语法类似于 C、Java 或 Scala 中的长整数常量（如 `3L` 表示 long 类型整数）。

#### 常见陷阱

定义常量宽度时，可能会遗漏 `.W` 后缀。例如：

```scala
1.U(32) // 错误
```

上例中，`(32)` 被解释为从位 32 提取单个位的操作，结果是一个值为 0 的单个位常量，而非宽度为 32 的常量。正确写法为：

```scala
1.U(32.W)
```

### 类型推导

Chisel 借助 Scala 的类型推导，在许多情况下可以省略显式的类型和宽度定义。例如，Chisel 可以自动推导常量的最小宽度，使硬件描述更加简洁易读。

### 进制表示

Chisel 支持通过字符串定义其他进制（如十六进制、八进制和二进制）的常量，前缀分别为 `h`、`o` 和 `b`：

```scala
"hff".U      // 十六进制表示 255
"o377".U     // 八进制表示 255
"b1111_1111".U // 二进制表示 255，支持使用下划线分组以提高可读性
```

### 字符常量

可以直接使用 ASCII 编码的字符作为常量：

```scala
val aChar = 'A'.U // 定义字符 'A' 对应的常量
```

### 布尔类型

Chisel 定义了类型 `Bool`，用于表示逻辑值 `true` 和 `false`：

```scala
Bool()       // 定义 Bool 类型
true.B       // 布尔值 true
false.B      // 布尔值 false
```

------

## 2.2 组合逻辑电路

组合逻辑电路是通过逻辑门连接信号来实现功能的电路，输出仅依赖输入的当前状态。以下是一个简单的逻辑表达式：

逻辑表达式：(a&b)∣c\text{逻辑表达式：} (a \& b) | c

### 图示与代码

如图 2.1 所示，表达式 `(a & b) | c` 的逻辑对应以下 Chisel 代码：

```scala
val a = Wire(Bool())
val b = Wire(Bool())
val c = Wire(Bool())
val result = (a & b) | c
```

- **逻辑门**：`&` 表示与操作（AND），`|` 表示或操作（OR）。
- **信号类型**：信号 `a`、`b` 和 `c` 可以是单个位或多个位。

图形和 Chisel 表达式在功能上是等价的。这种简单的逻辑是更复杂电路设计的基础。

------

本节介绍了数字设计的基础数据类型、常量和组合逻辑，为后续章节构建更复杂的电路模块奠定了理论和实践基础。





## 2.2 组合逻辑电路

Chisel 使用布尔代数运算符来描述组合逻辑电路，这些运算符在 C、Java 和 Scala 等编程语言中广泛使用。以下是典型的逻辑操作示例：

```scala
val logic = (a & b) | c
```

该代码描述了一个简单的组合逻辑电路：

- `a & b` 表示两个信号通过 **与门**（AND gate）结合。
- `(a & b) | c` 表示与门输出与信号 `c` 通过 **或门**（OR gate）结合。

图 2.1 展示了这一逻辑表达式的电路图。需要注意的是，这些信号可以是单个位，也可以是多位向量。

### 运算符与类型推导

在上述示例中，`logic` 的类型和宽度是从表达式中自动推导的，无需显式声明。这种类型推导简化了硬件描述。

------

### 标准逻辑运算

Chisel 提供了以下标准逻辑运算符：

- 按位与

  ：

  ```scala
  val and = a & b
  ```

- 按位或

  ：

  ```scala
  val or = a | b
  ```

- 按位异或

  ：

  ```scala
  val xor = a ^ b
  ```

- 按位非

  ：

  ```scala
  val not = ~a
  ```

### 算术运算

Chisel 同样支持常见的算术运算：

- 加法：

  ```scala
  val add = a + b
  ```

- 减法：

  ```scala
  val sub = a - b
  ```

- 取反：

  ```scala
  val neg = -a
  ```

- 乘法：

  ```scala
  val mul = a * b
  ```

- 除法：

  ```scala
  val div = a / b
  ```

- 取模：

  ```scala
  val mod = a % b
  ```

运算结果的宽度依赖于操作数：

- 加法和减法：结果宽度为操作数的最大宽度。
- 乘法：结果宽度为两个操作数宽度之和。
- 除法和取模：结果宽度通常与被除数（分子）的宽度一致。

------

### 信号定义与操作

#### 定义与赋值

Chisel 中可以通过 `Wire` 定义一个信号，随后使用 `:=` 运算符对信号赋值：

```scala
val w = Wire(UInt())
w := a & b
```

#### 位提取

可以从一个信号中提取特定位或位字段：

- 提取单个位：

  ```scala
  val sign = x(31) // 提取第 31 位
  ```

- 提取子字段：

  ```scala
  val lowByte = largeWord(7, 0) // 提取第 0 到第 7 位
  ```

#### 位拼接

位字段可以通过 `##` 运算符拼接：

```scala
val word = highByte ## lowByte
```

或者使用等效的 `Cat` 函数：

```scala
val word = Cat(highByte, lowByte)
```

------

### 运算符优先级

Chisel 的运算符优先级遵循 Scala 的规则，与 Java/C 相似，但与 Verilog 和 VHDL 存在差异：

- Verilog 的运算符优先级与 C 相同。
- VHDL 的逻辑运算符没有优先级，按从左到右的顺序计算。

建议在复杂表达式中使用括号确保运算顺序清晰。例如：

```scala
val result = ((a & b) | c) ^ d
```

------

### Chisel 数据类型的常用函数

Chisel 数据类型提供了丰富的内置函数和运算符，可用于硬件设计。具体列表可参考 [Chisel 文档](https://www.chisel-lang.org/) 或后续章节中的详细说明。

通过这些逻辑和算术运算符，以及灵活的信号操作方法，Chisel 能够高效地描述各种复杂的组合逻辑电路。







## 2.2 组合逻辑电路：运算符与硬件函数

Chisel 提供了丰富的运算符和硬件函数来描述硬件行为。以下是两张表格总结的内容，帮助更好地理解和使用这些功能。

------

### 表 2.1：Chisel 定义的硬件运算符

| **运算符**  | **描述**                                  | **支持的数据类型**                   |
| ----------- | ----------------------------------------- | ------------------------------------ |
| `* / %`     | 乘法、除法、取模                          | `UInt`, `SInt`                       |
| `+ -`       | 加法、减法                                | `UInt`, `SInt`                       |
| `==` `/=`   | 判断相等、不等，返回 `Bool`               | `UInt`, `SInt`, 返回 `Bool`          |
| `> >= < <=` | 比较运算符，返回 `Bool`                   | `UInt`, `SInt`, 返回 `Bool`          |
| `<< >>`     | 左移、右移（`SInt` 类型右移时带符号扩展） | `UInt`, `SInt`                       |
| `~`         | 按位非（NOT）                             | `UInt`, `SInt`, `Bool`               |
| `&          | ^`                                        | 按位与（AND）、或（OR）、异或（XOR） |
| `!`         | 逻辑非（NOT）                             | `Bool`                               |
| `&&         |                                           | `                                    |

这些运算符与软件语言（如 C、Java 或 Scala）中定义的运算符相似，可以直接用于描述硬件行为。

------

### 表 2.2：Chisel 定义的硬件函数

| **函数**                  | **描述**                                   | **支持的数据类型**          |
| ------------------------- | ------------------------------------------ | --------------------------- |
| `v.andR` `v.orR` `v.xorR` | 按位与、或、异或的归约操作，返回单个布尔值 | `UInt`, `SInt`, 返回 `Bool` |
| `v(n)`                    | 提取信号的第 `n` 位                        | `UInt`, `SInt`              |
| `v(end, start)`           | 提取从 `start` 位到 `end` 位的子字段       | `UInt`, `SInt`              |
| `Fill(n, v)`              | 将位字段 `v` 复制 `n` 次形成新的位向量     | `UInt`, `SInt`              |
| `a ## b`                  | 按位拼接两个信号                           | `UInt`, `SInt`              |
| `Cat(a, b, ...)`          | 按位拼接多个信号，功能等同于 `##`          | `UInt`, `SInt`              |

#### 示例与说明

1. **按位归约操作**：

   - `andR`：对所有位取按位与，若所有位均为 1 则返回 `true`。

   - 示例：

     ```scala
     val result = v.andR
     ```

2. **位提取**：

   - 提取单个位：

     ```scala
     val bit = v(3) // 提取第 3 位
     ```

   - 提取子字段：

     ```scala
     val subField = v(7, 4) // 提取第 4 到第 7 位
     ```

3. **位拼接与填充**：

   - 拼接两个信号：

     ```scala
     val combined = highByte ## lowByte
     ```

   - 使用 

     ```
     Fill
     ```

      进行位复制：

     ```scala
     val replicated = Fill(4, 1.U) // 将 1 复制 4 次，生成 4'b1111
     ```

------

### 运算符优先级

- Chisel 运算符的优先级继承自 Scala，与 Java/C 相似，但与 Verilog 和 VHDL 存在差异。

- 建议

  ：在表达式中使用括号来确保逻辑的清晰性，例如：

  ```scala
  val result = ((a & b) | c) ^ d
  ```

------

### 总结

通过表 2.1 和表 2.2 中的内容，可以快速掌握 Chisel 提供的主要运算符和函数。结合这些工具，您能够高效地描述复杂的组合逻辑电路，并实现更加灵活的硬件设计。





## 2.2.1 多路复用器（Multiplexer）

多路复用器是一种在多个输入中选择一个输出的电路。在最基本的形式中，它在两种输入间进行选择，如图 2.2 所示，这是一个 **2:1 多路复用器**（简称 MUX）。

- 工作原理

  ：根据选择信号 

  ```
  sel
  ```

   的值，输出 

  ```
  y
  ```

   将对应输入信号 

  ```
  a
  ```

   或 

  ```
  b
  ```

  ：

  - 当 `sel` 为 1 时，`y` 输出 `a`；
  - 当 `sel` 为 0 时，`y` 输出 `b`。

------

### 在 Chisel 中使用多路复用器

虽然多路复用器可以用基本的逻辑操作（如 `AND` 和 `OR`）实现，但由于其广泛使用，Chisel 提供了内置的 `Mux` 函数来简化设计。以下是多路复用器的定义：

```scala
val result = Mux(sel, a, b)
```

#### 参数说明

1. **`sel`**：选择信号，为 `Bool` 类型。如果 `sel` 为 `true.B`，选择输入 `a`，否则选择输入 `b`。
2. **`a` 和 `b`**：两个输入信号，可以是任何 Chisel 数据类型（如 `UInt`、`SInt`）或聚合类型（如 `Bundle` 或 `Vec`）。两者必须具有相同的类型。

#### 示例

```scala
val a = Wire(UInt(8.W))
val b = Wire(UInt(8.W))
val sel = Wire(Bool())
val y = Mux(sel, a, b)
```

- 如果 `sel` 为 `true.B`，`y` 的值为 `a`；
- 如果 `sel` 为 `false.B`，`y` 的值为 `b`。

------

### 功能与应用

结合逻辑运算、算术运算和多路复用器，几乎可以描述所有的组合逻辑电路。多路复用器特别适合以下场景：

1. **选择路径**：在多个数据路径中选择一条作为输出。
2. **实现条件判断**：替代传统的条件语句（如 `if-else` 或 `switch`）。

虽然 `Mux` 功能强大，但 Chisel 还提供了更高级的控制抽象，使得描述复杂的组合逻辑更加简洁优雅。这些高级功能将在第 5 章详细介绍。

------

### 下一步：状态元素

除了组合逻辑外，设计数字电路还需要状态元素（如寄存器）。状态元素将在后续章节中详细讨论，并展示如何在 Chisel 中实现它们。





寄存器的输入通过 `:=` 更新运算符连接，输出可以直接通过寄存器名称使用。例如：

```scala
reg := d      // 将输入信号 d 赋值给寄存器
val q = reg   // 使用寄存器的当前值
```

1. **简化的定义方式**
    Chisel 提供了更加简洁的方式将寄存器与输入信号连接：

   ```scala
   val nextReg = RegNext(d)
   ```

   上述代码定义了一个寄存器，其输入为 `d`，时钟信号隐式连接，复位值默认为零。

2. **初始化与连接**
    也可以同时为寄存器定义输入信号及初始值：

   ```scala
   val bothReg = RegNext(d, 0.U) // 输入为 d，复位初始值为 0
   ```

------

### 图示解析

图 2.3 展示了寄存器的基本电路结构：

- **时钟信号（clock）**：隐式连接，用于控制寄存器的更新。
- **同步复位（reset）**：初始化寄存器值为 `0`，在时钟信号作用下进行同步复位。
- **输入信号（d）**：赋值给寄存器。
- **输出信号（q）**：寄存器的当前存储值。

------

### 命名惯例

为了区分组合逻辑信号与寄存器信号，通常使用以下命名约定：

1. **寄存器名称后缀**：为寄存器名称添加 `Reg` 后缀，例如 `cntReg`。
2. **驼峰命名法**：多词标识符采用驼峰式命名，例如 `nextReg`。变量和函数以小写字母开头，类名和模块名以大写字母开头。

尽管 Chisel 的标识符命名较为自由，但应尽量采用简洁且具有描述性的名称。注意避免使用 Chisel 的保留字，具体列表请参考附录 A。

------

### 2.3.1 计数器

计数器是数字系统中一种基本操作，用于计数事件或定义时间间隔。计数器通常通过记录时钟周期来实现，例如在时间间隔到达时触发某种动作。

#### 示例：简单循环计数器

以下代码实现了一个简单的计数器，计数范围从 0 到 9，达到上限后重置为 0：

```scala
val cntReg = RegInit(0.U(8.W)) // 定义 8 位宽的计数器，复位初始值为 0
cntReg := Mux(cntReg === 9.U, 0.U, cntReg + 1.U)
```

- 工作原理

  ：

  - 当 `cntReg` 的值等于 9 时，使用 `Mux` 将计数器复位为 0。
  - 否则，计数器值递增 1。

#### 代码解析：

1. **寄存器初始化**：`RegInit(0.U(8.W))` 定义一个 8 位宽的计数器，复位值为 0。

2. **条件判断**：`cntReg === 9.U` 用于判断计数器是否达到上限值。

3. 选择操作

   ：

   ```
   Mux
   ```

    实现条件选择：

   - 若达到上限值（`true`），计数器复位为 `0.U`；
   - 否则计数器加 1。

------

### 寄存器的应用场景

1. **状态存储**：寄存器用于存储当前的电路状态。
2. **时间控制**：通过计数器实现时序控制，如生成固定时间间隔信号。
3. **数据延迟**：寄存器可引入延迟信号，以便在多周期操作中协调数据流。

------

通过本节内容，您已经掌握了寄存器的基本定义和使用方法，包括初始化、连接输入信号，以及设计简单计数器的应用。寄存器在复杂数字电路设计中扮演核心角色，是理解状态机和时序电路的基础。





